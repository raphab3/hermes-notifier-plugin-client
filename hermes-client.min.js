class HermesClient{constructor(e={}){this.baseUrl=e.baseUrl||"http://localhost:8000",this.appToken=e.appToken||null,this.profileToken=e.profileToken||null,this.userId=e.userId||null,this.timeout=e.timeout||3e4,this.debug=e.debug||!1,this.sseEnabled=!1!==e.sseEnabled,this.reconnectDelay=e.reconnectDelay||5e3,this.maxReconnectAttempts=e.maxReconnectAttempts||10,this.eventSource=null,this.reconnectAttempts=0,this.isConnected=!1,this.listeners={notification:[],connected:[],disconnected:[],error:[],unreadCount:[]},this.log("HermesClient initialized",e)}log(...e){this.debug&&console.log("[HermesClient]",...e)}async sendNotification(e={}){const{userId:t,title:i,body:n,sourceSystem:o="web-app",priority:r="normal",channels:s=["in_app"],metadata:a={}}=e;if(!t)throw new Error("userId is required");if(!i||!n)throw new Error("title and body are required");const c=this.appToken;if(!c)throw new Error("appToken is required for sending notifications");this.log("Sending notification",e);const h=await fetch(`${this.baseUrl}/api/notifications/send`,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${c}`},body:JSON.stringify({user_id:t,title:i,body:n,source_system:o,priority:r,channels:s,metadata:a})});if(!h.ok){const e=await h.json().catch(()=>({error:"Unknown error"}));throw new Error(e.error||`HTTP ${h.status}`)}const d=await h.json();return this.log("Notification sent",d),d}async getNotifications(e={}){const{userId:t=this.userId,isRead:i=null,limit:n=20,offset:o=0}=e;if(!t)throw new Error("userId is required");const r=this.profileToken||this.appToken;if(!r)throw new Error("profileToken or appToken is required");const s=new URLSearchParams({limit:n.toString(),offset:o.toString()});null!==i&&s.append("is_read",i.toString()),this.log("Getting notifications",{userId:t,params:s.toString()});const a=await fetch(`${this.baseUrl}/api/notifications/user/${t}?${s}`,{headers:{Authorization:`Bearer ${r}`}});if(!a.ok){const e=await a.json().catch(()=>({error:"Unknown error"}));throw new Error(e.error||`HTTP ${a.status}`)}const c=await a.json();return this.log("Notifications received",c),c}async getUnreadCount(e=this.userId){if(!e)throw new Error("userId is required");const t=this.profileToken||this.appToken;if(!t)throw new Error("profileToken or appToken is required");this.log("Getting unread count",e);const i=await fetch(`${this.baseUrl}/api/notifications/user/${e}/unread-count`,{headers:{Authorization:`Bearer ${t}`}});if(!i.ok)throw new Error(`HTTP ${i.status}`);const n=await i.json();return this.log("Unread count",n),n.count||0}async markAsRead(e){if(!e)throw new Error("notificationId is required");const t=this.profileToken||this.appToken;if(!t)throw new Error("profileToken or appToken is required");this.log("Marking as read",e);const i=await fetch(`${this.baseUrl}/api/notifications/${e}/read`,{method:"PATCH",headers:{Authorization:`Bearer ${t}`}});if(!i.ok)throw new Error(`HTTP ${i.status}`);const n=await i.json();return this.log("Marked as read",n),n}async markAllAsRead(e=this.userId){if(!e)throw new Error("userId is required");const t=this.profileToken||this.appToken;if(!t)throw new Error("profileToken or appToken is required");this.log("Marking all as read",e);const i=await fetch(`${this.baseUrl}/api/notifications/user/${e}/read-all`,{method:"PATCH",headers:{Authorization:`Bearer ${t}`}});if(!i.ok)throw new Error(`HTTP ${i.status}`);const n=await i.json();return this.log("All marked as read",n),n}connectSSE(e=this.userId){if(!e)throw new Error("userId is required for SSE connection");const t=this.profileToken;if(!t)throw new Error("profileToken is required for SSE connection");this.eventSource&&(this.log("SSE already connected, disconnecting first"),this.disconnectSSE());const i=`${this.baseUrl}/sse/notifications/${e}/?token=${t}`;this.log("Connecting to SSE",i),this.eventSource=new EventSource(i),this.eventSource.onopen=()=>{this.log("SSE connection opened"),this.isConnected=!0,this.reconnectAttempts=0,this.emit("connected",{userId:e})},this.eventSource.onmessage=e=>{try{const t=JSON.parse(e.data);this.log("SSE message received",t),"notification"===t.type?this.emit("notification",t):"unread_count"===t.type?this.emit("unreadCount",t.count):"connected"===t.type&&this.emit("connected",t)}catch(e){this.log("Error parsing SSE message",e)}},this.eventSource.onerror=t=>{this.log("SSE error",t),this.isConnected=!1,this.emit("error",t),this.emit("disconnected",{reason:"error"}),this.reconnectAttempts<this.maxReconnectAttempts?(this.reconnectAttempts++,this.log(`Reconnecting in ${this.reconnectDelay}ms (attempt ${this.reconnectAttempts})`),setTimeout(()=>this.connectSSE(e),this.reconnectDelay)):this.log("Max reconnect attempts reached")}}disconnectSSE(){this.eventSource&&(this.log("Disconnecting SSE"),this.eventSource.close(),this.eventSource=null,this.isConnected=!1,this.emit("disconnected",{reason:"manual"}))}on(e,t){this.listeners[e]||(this.listeners[e]=[]),this.listeners[e].push(t),this.log(`Listener added for event: ${e}`)}off(e,t){if(!this.listeners[e])return;const i=this.listeners[e].indexOf(t);i>-1&&(this.listeners[e].splice(i,1),this.log(`Listener removed for event: ${e}`))}emit(e,t){this.listeners[e]&&this.listeners[e].forEach(i=>{try{i(t)}catch(t){this.log(`Error in ${e} listener`,t)}})}getStatus(){return{isConnected:this.isConnected,reconnectAttempts:this.reconnectAttempts,hasEventSource:!!this.eventSource}}}"undefined"!=typeof module&&module.exports&&(module.exports=HermesClient),"undefined"!=typeof window&&(window.HermesClient=HermesClient);